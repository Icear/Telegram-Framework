- 重新捋清逻辑
    - CoolQ方向
        - 不接受指令，只转发至Telegram端或转发来自Telegram端的消息
        - 接收到消息时将消息封装通过JMS接口发布，不保留数据
    - Telegram方向
        - 接受指令
        - 收到的所有消息封装通过JMS接口发布，不保留数据
        - 消息类型
            - 命令消息
                - 要求进行某种状态变更
                - 要求执行某种操作
                - 收到命令消息，发布至命令消息通道（点对点模式，针对每一个命令创建对应通道并发布）
            - 普通消息
                - 消息将被转发至CoolQ端，具体转发位置取决于状态
                - 收到普通消息，发布至普通消息通道（发布订阅模式）
            - 回复消息
                - 目前想法是回复某个消息时，若该消息来自CoolQ端，则将这个回复原路转发回CoolQ端
                - 收到消息时根据回复的消息来源，发布至各自的监听通道
    - 插件设计
        - 支持插件自行注册命令消息通道
            - （JMS默认监听与发布是分离的，可以让插件自行监听）
            - 放弃每一种命令单独一个通道，目前通道不需要这么多，顶多提供aop模式注解辅助过滤不关注的信息
            - 所以命令通道直接使用一个通道进行发布
        - 支持插件返回注册命令消息及释义
            - （便于生成命令表，方便查看，或在TelegramBot端注册）
            - 可以提供一个接口，调用所有实现这个接口的类获得数据， **但是这样没有做到强制**（目前只是自行编写插件，足够了）
        - 提供框架中已注册的各个Context的消息发布通道Topic以便创建监听（如CoolQ的消息发布通道）
            - 提供一个Context级别的常量，由Context自行发布，缺点是插件需要直接依赖于Context
            - 为了解决直接依赖的问题，框架级别地提供一个通道表，根据Context名进行索引，Context在初始化时进行注册，插件可以通过查询这个表来获得默认通道（目前不会分离服务，所以不实现到这个层次）
            - 见下一条第二点
        - 提供插件的回复消息监听通道（这个只针对于TelegramBot），根据插件名称生成对应通道名
            - 创建一个工具类即可，但这样插件也是直接依赖于Context，缺点是插件需要直接依赖与Context
            - 直接依赖吧。。如果真的到了要拆分的时候，直接把Context的这部分做成单独的包，在依赖里添加就好了，也能反应出它使用的Context种类，上一条同理
        
        - 用的那个库里三种消息都是一起的。。。。 上面想的全废了 
        
        - 那现在就手动区分成三种消息
            - 命令消息的话主动在消息的header上标记命令内容，这样方便后面写过滤，然后就不根据命令区分通道了，感觉每个通道的消息数会很少，不如合并起来，只是插件的权限就不能很好控制
                - 其实要控制也可以，强制打过滤注解，然后不注解的不允许进入周期
            - 剩下两个消息直接丢进对应的消息通道里  