## 当前进度
- 挑选合适的事件分发工具
	- redis
		- 没有消息确认机制
		- 有spring-data-redis实现，可以直接使用
	- disque
		- redis原作者antirez开发
		- 专门从redis衍生用于事件队列模型
		- 有对应的java实现jedisque
		- 分布式乱序队列
		- 只是一个纯粹的队列实现，支持持久化
		- 支持消息ACK和重试机制
		- OK就决定是你了
 	- spring-redis-mq
		- 个人开发，挑选优先级很低
	- **ActiveMQ**
	    - 原本感觉太大没打算用，但是SpringBoot自带了不用白不用23333  
- 重新捋清逻辑
    - CoolQ方向
        - 不接受指令，只转发至Telegram端或转发来自Telegram端的消息
        - 接收到消息时将消息封装通过JMS接口发布，不保留数据
    - Telegram方向
        - 接受指令
        - 收到的所有消息封装通过JMS接口发布，不保留数据
        - 消息类型
            - 命令消息
                - 要求进行某种状态变更
                - 要求执行某种操作
                - 收到命令消息，发布至命令消息通道（点对点模式，针对每一个命令创建对应通道并发布）
            - 普通消息
                - 消息将被转发至CoolQ端，具体转发位置取决于状态
                - 收到普通消息，发布至普通消息通道（发布订阅模式）
            - 回复消息
                - 目前想法是回复某个消息时，若该消息来自CoolQ端，则将这个回复原路转发回CoolQ端
                - 收到消息时根据回复的消息来源，发布至各自的监听通道
    - 插件设计
        - 支持插件自行注册命令消息通道
            - （JMS默认监听与发布是分离的，可以让插件自行监听）
            - 放弃每一种命令单独一个通道，目前通道不需要这么多，顶多提供aop模式注解辅助过滤不关注的信息
            - 所以命令通道直接使用一个通道进行发布
        - 支持插件返回注册命令消息及释义
            - （便于生成命令表，方便查看，或在TelegramBot端注册）
            - 可以提供一个接口，调用所有实现这个接口的类获得数据， **但是这样没有做到强制**（目前只是自行编写插件，足够了）
        - 提供框架中已注册的各个Context的消息发布通道Topic以便创建监听（如CoolQ的消息发布通道）
            - 提供一个Context级别的常量，由Context自行发布，缺点是插件需要直接依赖于Context
            - 为了解决直接依赖的问题，框架级别地提供一个通道表，根据Context名进行索引，Context在初始化时进行注册，插件可以通过查询这个表来获得默认通道（目前不会分离服务，所以不实现到这个层次）
            - 见下一条第二点
        - 提供插件的回复消息监听通道（这个只针对于TelegramBot），根据插件名称生成对应通道名
            - 创建一个工具类即可，但这样插件也是直接依赖于Context，缺点是插件需要直接依赖与Context
            - 直接依赖吧。。如果真的到了要拆分的时候，直接把Context的这部分做成单独的包，在依赖里添加就好了，也能反应出它使用的Context种类，上一条同理
        
        - 用的那个库里三种消息都是一起的。。。。 上面想的全废了 
            
        